-- | Security and negative tests (20 tests).
module SimpleToken.Test.Negative where

import DA.Date
import DA.Time
import DA.TextMap qualified as TextMap

import Splice.Api.Token.MetadataV1
import Splice.Api.Token.HoldingV1
import Splice.Api.Token.TransferInstructionV1

import SimpleToken.Holding
import SimpleToken.Rules
import SimpleToken.Preapproval
import SimpleToken.ContextUtils
import SimpleToken.Testing.SimpleRegistry
import SimpleToken.Testing.WalletClient
import SimpleToken.Test.Setup

import Daml.Script

-- Helper: make a transfer and try to submit it (returns the enriched choice for custom submission)
mkAndGetTransfer : SimpleRegistry -> Party -> Party -> Decimal -> [ContractId Holding] -> Script (EnrichedChoice TransferFactory TransferFactory_Transfer)
mkAndGetTransfer registry sender receiver amount inputCids = do
  let transfer = Transfer with
        sender; receiver; amount
        instrumentId = registry.instrumentId
        requestedAt = demoTime
        executeBefore = futureDeadline
        inputHoldingCids = inputCids
        meta = emptyMetadata
  getTransferFactory registry transfer emptyExtraArgs

-- Test 13: Wrong expectedAdmin
test_wrongExpectedAdmin : Script ()
test_wrongExpectedAdmin = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
  [h1] <- fundParty registry alice 100.0
  wrongAdmin <- allocatePartyByHint (PartyIdHint "wrong-admin")
  [(rulesCid, _)] <- query @SimpleTokenRules registry.admin
  let tfCid = toInterfaceContractId @TransferFactory rulesCid
  rulesDisc <- queryDisc @SimpleTokenRules registry.admin rulesCid
  let transfer = Transfer with
        sender = alice; receiver = alice; amount = 50.0
        instrumentId = registry.instrumentId
        requestedAt = demoTime; executeBefore = futureDeadline
        inputHoldingCids = [h1]; meta = emptyMetadata
  submitWithDiscMustFail alice rulesDisc $
    exerciseCmd tfCid TransferFactory_Transfer with
      expectedAdmin = wrongAdmin
      transfer
      extraArgs = emptyExtraArgs

-- Test 14: Future requestedAt
test_futureRequestedAt : Script ()
test_futureRequestedAt = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
  [h1] <- fundParty registry alice 100.0
  let transfer = Transfer with
        sender = alice; receiver = alice; amount = 50.0
        instrumentId = registry.instrumentId
        requestedAt = time (date 2025 Jan 1) 0 0 0  -- future
        executeBefore = futureDeadline
        inputHoldingCids = [h1]; meta = emptyMetadata
  enriched <- getTransferFactory registry transfer emptyExtraArgs
  submitWithDiscMustFail alice enriched.disclosures $
    exerciseCmd enriched.factoryCid enriched.arg

-- Test 15: Expired executeBefore
test_expiredExecuteBefore : Script ()
test_expiredExecuteBefore = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
  [h1] <- fundParty registry alice 100.0
  let transfer = Transfer with
        sender = alice; receiver = alice; amount = 50.0
        instrumentId = registry.instrumentId
        requestedAt = demoTime
        executeBefore = time (date 2023 Jan 1) 0 0 0  -- in the past
        inputHoldingCids = [h1]; meta = emptyMetadata
  enriched <- getTransferFactory registry transfer emptyExtraArgs
  submitWithDiscMustFail alice enriched.disclosures $
    exerciseCmd enriched.factoryCid enriched.arg

-- Test 16: Non-positive amount
test_nonPositiveAmount : Script ()
test_nonPositiveAmount = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
  [h1] <- fundParty registry alice 100.0
  let transfer = Transfer with
        sender = alice; receiver = alice; amount = 0.0
        instrumentId = registry.instrumentId
        requestedAt = demoTime; executeBefore = futureDeadline
        inputHoldingCids = [h1]; meta = emptyMetadata
  enriched <- getTransferFactory registry transfer emptyExtraArgs
  submitWithDiscMustFail alice enriched.disclosures $
    exerciseCmd enriched.factoryCid enriched.arg

-- Test 17: Wrong instrumentId
test_wrongInstrumentId : Script ()
test_wrongInstrumentId = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
  [h1] <- fundParty registry alice 100.0
  let badInstrumentId = InstrumentId with admin = registry.admin; id = "WrongToken"
  let transfer = Transfer with
        sender = alice; receiver = alice; amount = 50.0
        instrumentId = badInstrumentId
        requestedAt = demoTime; executeBefore = futureDeadline
        inputHoldingCids = [h1]; meta = emptyMetadata
  enriched <- getTransferFactory registry transfer emptyExtraArgs
  submitWithDiscMustFail alice enriched.disclosures $
    exerciseCmd enriched.factoryCid enriched.arg

-- Test 18: Empty input holdings
test_emptyInputHoldings : Script ()
test_emptyInputHoldings = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
  let transfer = Transfer with
        sender = alice; receiver = alice; amount = 50.0
        instrumentId = registry.instrumentId
        requestedAt = demoTime; executeBefore = futureDeadline
        inputHoldingCids = []; meta = emptyMetadata
  enriched <- getTransferFactory registry transfer emptyExtraArgs
  submitWithDiscMustFail alice enriched.disclosures $
    exerciseCmd enriched.factoryCid enriched.arg

-- Test 19: Holding contention -- two transfers using same holding, one fails
test_holdingContention : Script ()
test_holdingContention = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
      bob = parties.bob
  [h1] <- fundParty registry alice 100.0
  -- Create preapproval for bob so both are direct transfers
  _ <- createPreapproval registry bob None
  -- First transfer succeeds
  let transfer1 = Transfer with
        sender = alice; receiver = bob; amount = 50.0
        instrumentId = registry.instrumentId
        requestedAt = demoTime; executeBefore = futureDeadline
        inputHoldingCids = [h1]; meta = emptyMetadata
  enriched1 <- getTransferFactory registry transfer1 emptyExtraArgs
  _ <- submitWithDisc alice enriched1.disclosures $
    exerciseCmd enriched1.factoryCid enriched1.arg
  -- Second transfer with same holding must fail (already archived)
  enriched2 <- getTransferFactory registry transfer1 emptyExtraArgs
  submitWithDiscMustFail alice enriched2.disclosures $
    exerciseCmd enriched2.factoryCid enriched2.arg

-- Test 20: Unauthorized accept (non-receiver tries to accept)
test_unauthorizedAccept : Script ()
test_unauthorizedAccept = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
      bob = parties.bob
      charlie = parties.charlie
  [h1] <- fundParty registry alice 100.0
  let transfer = Transfer with
        sender = alice; receiver = bob; amount = 100.0
        instrumentId = registry.instrumentId
        requestedAt = demoTime; executeBefore = futureDeadline
        inputHoldingCids = [h1]; meta = emptyMetadata
  enriched <- getTransferFactory registry transfer emptyExtraArgs
  result <- submitWithDisc alice enriched.disclosures $
    exerciseCmd enriched.factoryCid enriched.arg
  case result.output of
    TransferInstructionResult_Pending instrCid -> do
      -- Charlie (not receiver) tries to accept -> must fail
      submitMustFail charlie $ exerciseCmd instrCid TransferInstruction_Accept with
        extraArgs = emptyExtraArgs
    _ -> fail "Expected Pending"

-- Test 21: Expired transfer accept (after executeBefore)
test_expiredTransferAccept : Script ()
test_expiredTransferAccept = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
      bob = parties.bob
  [h1] <- fundParty registry alice 100.0
  -- Use a near-future deadline
  let nearFuture = time (date 2024 Jan 2) 0 0 0
  let transfer = Transfer with
        sender = alice; receiver = bob; amount = 100.0
        instrumentId = registry.instrumentId
        requestedAt = demoTime; executeBefore = nearFuture
        inputHoldingCids = [h1]; meta = emptyMetadata
  enriched <- getTransferFactory registry transfer emptyExtraArgs
  result <- submitWithDisc alice enriched.disclosures $
    exerciseCmd enriched.factoryCid enriched.arg
  case result.output of
    TransferInstructionResult_Pending instrCid -> do
      -- Advance time past the deadline
      setTime (time (date 2024 Jan 3) 0 0 0)
      -- Bob tries to accept -> must fail (expired)
      submitMustFail bob $ exerciseCmd instrCid TransferInstruction_Accept with
        extraArgs = emptyExtraArgs
    _ -> fail "Expected Pending"

-- Test 22: Preapproval instrumentId mismatch (cross-instrument attack)
test_preapprovalInstrumentIdMismatch : Script ()
test_preapprovalInstrumentIdMismatch = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
      bob = parties.bob
  -- Create a multi-instrument registry
  registry2 <- initializeMulti "admin2" ["TokenA", "TokenB"]
  let instrA = InstrumentId with admin = registry2.admin; id = "TokenA"
      instrB = InstrumentId with admin = registry2.admin; id = "TokenB"
  -- Create holding in TokenA
  hA <- createHoldingForInstrument registry2.admin alice instrA 100.0
  -- Create preapproval for bob but for TokenB
  _ <- submitMulti [registry2.admin, bob] [] $ createCmd TransferPreapproval with
    admin = registry2.admin
    receiver = bob
    instrumentId = instrB  -- Different instrument!
    expiresAt = None
    meta = emptyMetadata
  -- Try to transfer TokenA using TokenB preapproval -> should fail at preapproval validation
  let transfer = Transfer with
        sender = alice; receiver = bob; amount = 50.0
        instrumentId = instrA
        requestedAt = demoTime; executeBefore = futureDeadline
        inputHoldingCids = [hA]; meta = emptyMetadata
  -- Manually build context with the wrong preapproval
  [(rulesCid, _)] <- query @SimpleTokenRules registry2.admin
  preapprovals <- queryFilter @TransferPreapproval registry2.admin (\p -> p.receiver == bob)
  case preapprovals of
    (pCid, _) :: _ -> do
      let tfCid = toInterfaceContractId @TransferFactory rulesCid
      rulesDisc <- queryDisc @SimpleTokenRules registry2.admin rulesCid
      pDisc <- queryDisc @TransferPreapproval registry2.admin pCid
      let ctx = ChoiceContext with
            values = TextMap.fromList [(transferPreapprovalContextKey, AV_ContractId (coerceContractId pCid))]
      submitWithDiscMustFail alice (rulesDisc <> pDisc) $
        exerciseCmd tfCid TransferFactory_Transfer with
          expectedAdmin = registry2.admin
          transfer
          extraArgs = ExtraArgs with context = ctx; meta = emptyMetadata
    [] -> fail "Preapproval not found"

-- Test 23: Unexpired locked holding rejected as input
test_unexpiredLockedHoldingInput : Script ()
test_unexpiredLockedHoldingInput = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
  -- Create a locked holding with future expiry
  lockedCid <- submitMulti [registry.admin, alice] [] $ createCmd LockedSimpleHolding with
    admin = registry.admin
    owner = alice
    instrumentId = registry.instrumentId
    amount = 100.0
    lock = Lock with
      holders = [registry.admin]
      expiresAt = Some futureDeadline
      expiresAfter = None
      context = Some "test lock"
    extraObservers = []
    meta = emptyMetadata
  let lockedHoldingCid = toInterfaceContractId @Holding lockedCid
  let transfer = Transfer with
        sender = alice; receiver = alice; amount = 50.0
        instrumentId = registry.instrumentId
        requestedAt = demoTime; executeBefore = futureDeadline
        inputHoldingCids = [lockedHoldingCid]; meta = emptyMetadata
  enriched <- getTransferFactory registry transfer emptyExtraArgs
  submitWithDiscMustFail alice enriched.disclosures $
    exerciseCmd enriched.factoryCid enriched.arg

-- Test 24: Expired locked holding ACCEPTED as input (positive test)
test_expiredLockedHoldingInput : Script ()
test_expiredLockedHoldingInput = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
  -- Create a locked holding with past expiry
  let pastTime = time (date 2023 Dec 31) 0 0 0
  lockedCid <- submitMulti [registry.admin, alice] [] $ createCmd LockedSimpleHolding with
    admin = registry.admin
    owner = alice
    instrumentId = registry.instrumentId
    amount = 100.0
    lock = Lock with
      holders = [registry.admin]
      expiresAt = Some pastTime  -- Already expired
      expiresAfter = None
      context = Some "expired lock"
    extraObservers = []
    meta = emptyMetadata
  let lockedHoldingCid = toInterfaceContractId @Holding lockedCid
  let transfer = Transfer with
        sender = alice; receiver = alice; amount = 100.0
        instrumentId = registry.instrumentId
        requestedAt = demoTime; executeBefore = futureDeadline
        inputHoldingCids = [lockedHoldingCid]; meta = emptyMetadata
  enriched <- getTransferFactory registry transfer emptyExtraArgs
  -- This should SUCCEED because the lock is expired
  result <- submitWithDisc alice enriched.disclosures $
    exerciseCmd enriched.factoryCid enriched.arg
  case result.output of
    TransferInstructionResult_Completed _ -> pure ()
    _ -> fail "Expected Completed for expired locked holding"
  checkBalance alice registry.instrumentId 100.0

-- Test 25: Zero-amount SimpleHolding cannot be created (defense-in-depth)
test_zeroAmountHolding : Script ()
test_zeroAmountHolding = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
  -- Direct create with amount = 0.0 must fail
  submitMultiMustFail [registry.admin, alice] [] $ createCmd SimpleHolding with
    admin = registry.admin
    owner = alice
    instrumentId = registry.instrumentId
    amount = 0.0
    meta = emptyMetadata

-- Test 26: Negative-amount SimpleHolding cannot be created
test_negativeAmountHolding : Script ()
test_negativeAmountHolding = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
  submitMultiMustFail [registry.admin, alice] [] $ createCmd SimpleHolding with
    admin = registry.admin
    owner = alice
    instrumentId = registry.instrumentId
    amount = -10.0
    meta = emptyMetadata

-- Test 27: Zero-amount LockedSimpleHolding cannot be created
test_zeroAmountLockedHolding : Script ()
test_zeroAmountLockedHolding = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
  submitMultiMustFail [registry.admin, alice] [] $ createCmd LockedSimpleHolding with
    admin = registry.admin
    owner = alice
    instrumentId = registry.instrumentId
    amount = 0.0
    lock = Lock with
      holders = [registry.admin]
      expiresAt = Some futureDeadline
      expiresAfter = None
      context = Some "test"
    extraObservers = []
    meta = emptyMetadata

-- Test 28: TransferPreapproval_Send rejects zero amount (defense-in-depth)
test_preapprovalZeroAmount : Script ()
test_preapprovalZeroAmount = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
      bob = parties.bob
  -- Create preapproval for bob
  preapprovalCid <- createPreapproval registry bob None
  -- Exercise the choice directly with amount = 0.0 (bypassing factory validation)
  submitMultiMustFail [registry.admin, alice] [] $
    exerciseCmd preapprovalCid TransferPreapproval_Send with
      sender = alice
      transferInstrumentId = registry.instrumentId
      amount = 0.0
      totalInput = 100.0
      holdingMeta = emptyMetadata

-- NOTE: Contract keys on SimpleTokenRules and TransferPreapproval (AUDIT0 #30-31)
-- are NOT implementable on Daml LF 2.1 (Canton 3.x dropped contract key support).
-- Singleton semantics must be enforced at the application/off-ledger level.

-- Test 29: Owner can unlock an expired locked holding
test_ownerUnlockExpiredLock : Script ()
test_ownerUnlockExpiredLock = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
  -- Create a locked holding with a near-future expiry
  let nearFuture = time (date 2024 Jan 2) 0 0 0
  lockedCid <- submitMulti [registry.admin, alice] [] $ createCmd LockedSimpleHolding with
    admin = registry.admin
    owner = alice
    instrumentId = registry.instrumentId
    amount = 100.0
    lock = Lock with
      holders = [registry.admin]
      expiresAt = Some nearFuture
      expiresAfter = None
      context = Some "test lock"
    extraObservers = []
    meta = emptyMetadata
  -- Advance time past lock expiry
  setTime (time (date 2024 Jan 3) 0 0 0)
  -- Owner unlocks -> should succeed, returning an unlocked SimpleHolding
  _ <- submit alice $ exerciseCmd lockedCid LockedSimpleHolding_Unlock
  checkBalance alice registry.instrumentId 100.0

-- Test 30: Owner cannot unlock an unexpired locked holding
test_ownerUnlockUnexpiredLock : Script ()
test_ownerUnlockUnexpiredLock = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
  lockedCid <- submitMulti [registry.admin, alice] [] $ createCmd LockedSimpleHolding with
    admin = registry.admin
    owner = alice
    instrumentId = registry.instrumentId
    amount = 100.0
    lock = Lock with
      holders = [registry.admin]
      expiresAt = Some futureDeadline
      expiresAfter = None
      context = Some "test lock"
    extraObservers = []
    meta = emptyMetadata
  -- Try to unlock while lock is still active -> must fail
  submitMustFail alice $ exerciseCmd lockedCid LockedSimpleHolding_Unlock

-- Test 31: Reject succeeds after owner unlocks expired locked holding (expireLockKey)
test_rejectAfterOwnerUnlock : Script ()
test_rejectAfterOwnerUnlock = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
      bob = parties.bob
  [h1] <- fundParty registry alice 100.0
  -- Create two-step transfer with near-future deadline
  let nearFuture = time (date 2024 Jan 2) 0 0 0
  let transfer = Transfer with
        sender = alice; receiver = bob; amount = 100.0
        instrumentId = registry.instrumentId
        requestedAt = demoTime; executeBefore = nearFuture
        inputHoldingCids = [h1]; meta = emptyMetadata
  enriched <- getTransferFactory registry transfer emptyExtraArgs
  result <- submitWithDisc alice enriched.disclosures $
    exerciseCmd enriched.factoryCid enriched.arg
  case result.output of
    TransferInstructionResult_Pending instrCid -> do
      -- Advance time past deadline (lock expires at executeBefore)
      setTime (time (date 2024 Jan 3) 0 0 0)
      -- Alice unlocks the expired locked holding
      [(lockedCid, _)] <- queryFilter @LockedSimpleHolding registry.admin
        (\h -> h.owner == alice)
      _ <- submit alice $ exerciseCmd lockedCid LockedSimpleHolding_Unlock
      -- Alice has 100.0 back from unlock
      checkBalance alice registry.instrumentId 100.0
      -- Bob rejects with expire-lock = False (locked holding already archived)
      let abortArgs = ExtraArgs with
            context = ChoiceContext with
              values = TextMap.fromList [(expireLockContextKey, AV_Bool False)]
            meta = emptyMetadata
      rejectResult <- submit bob $ exerciseCmd instrCid TransferInstruction_Reject with
        extraArgs = abortArgs
      case rejectResult.output of
        TransferInstructionResult_Failed -> pure ()
        _ -> fail "Expected Failed"
      -- No double-return: alice still has exactly 100.0
      checkBalance alice registry.instrumentId 100.0
    _ -> fail "Expected Pending"

-- Test 32: Withdraw succeeds after owner unlocks expired locked holding
test_withdrawAfterOwnerUnlock : Script ()
test_withdrawAfterOwnerUnlock = do
  TestEnv{..} <- setupTestEnv
  let alice = parties.alice
      bob = parties.bob
  [h1] <- fundParty registry alice 100.0
  let nearFuture = time (date 2024 Jan 2) 0 0 0
  let transfer = Transfer with
        sender = alice; receiver = bob; amount = 100.0
        instrumentId = registry.instrumentId
        requestedAt = demoTime; executeBefore = nearFuture
        inputHoldingCids = [h1]; meta = emptyMetadata
  enriched <- getTransferFactory registry transfer emptyExtraArgs
  result <- submitWithDisc alice enriched.disclosures $
    exerciseCmd enriched.factoryCid enriched.arg
  case result.output of
    TransferInstructionResult_Pending instrCid -> do
      setTime (time (date 2024 Jan 3) 0 0 0)
      [(lockedCid, _)] <- queryFilter @LockedSimpleHolding registry.admin
        (\h -> h.owner == alice)
      _ <- submit alice $ exerciseCmd lockedCid LockedSimpleHolding_Unlock
      checkBalance alice registry.instrumentId 100.0
      -- Alice withdraws with expire-lock = False
      let abortArgs = ExtraArgs with
            context = ChoiceContext with
              values = TextMap.fromList [(expireLockContextKey, AV_Bool False)]
            meta = emptyMetadata
      withdrawResult <- submit alice $ exerciseCmd instrCid TransferInstruction_Withdraw with
        extraArgs = abortArgs
      case withdrawResult.output of
        TransferInstructionResult_Failed -> pure ()
        _ -> fail "Expected Failed"
      checkBalance alice registry.instrumentId 100.0
    _ -> fail "Expected Pending"
