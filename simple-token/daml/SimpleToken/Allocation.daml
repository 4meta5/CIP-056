-- | Allocation for DvP settlement.
-- SimpleAllocation: backed by a locked holding, supports execute/cancel/withdraw.
module SimpleToken.Allocation where

import Splice.Api.Token.MetadataV1
import Splice.Api.Token.HoldingV1
import Splice.Api.Token.AllocationV1

import SimpleToken.Holding
import SimpleToken.ContextUtils

-- | A funded allocation of holdings to a settlement leg.
template SimpleAllocation
  with
    admin : Party
    allocation : AllocationSpecification
    lockedHoldingCid : ContractId LockedSimpleHolding
  where
    signatory admin, allocation.transferLeg.sender
    observer allocation.settlement.executor, allocation.transferLeg.receiver

    interface instance Allocation for SimpleAllocation where
      view = AllocationView with
        allocation
        holdingCids = [toInterfaceContractId @Holding lockedHoldingCid]
        meta = emptyMetadata

      allocation_executeTransferImpl _selfCid arg = do
        -- Validate deadline before archival (Gap 8)
        now <- getTime
        assertMsg "Settlement has expired (settleBefore passed)"
          (now < allocation.settlement.settleBefore)
        lockedHolding <- fetch lockedHoldingCid
        archive lockedHoldingCid
        let totalInput = lockedHolding.amount
            leg = allocation.transferLeg
        -- Create receiver holding
        receiverCid <- create SimpleHolding with
          admin
          owner = leg.receiver
          instrumentId = leg.instrumentId
          amount = leg.amount
          meta = arg.extraArgs.meta
        -- Create sender change if needed
        senderChangeCids <- if totalInput > leg.amount
          then do
            changeCid <- create SimpleHolding with
              admin
              owner = leg.sender
              instrumentId = leg.instrumentId
              amount = totalInput - leg.amount
              meta = emptyMetadata
            pure [toInterfaceContractId @Holding changeCid]
          else pure []
        pure Allocation_ExecuteTransferResult with
          senderHoldingCids = senderChangeCids
          receiverHoldingCids = [toInterfaceContractId @Holding receiverCid]
          meta = txKindMeta "transfer"

      allocation_cancelImpl _selfCid arg = do
        releaseAllocatedFunds admin allocation lockedHoldingCid arg.extraArgs

      allocation_withdrawImpl _selfCid _arg = do
        -- Validate allocateBefore deadline
        now <- getTime
        assertMsg "Cannot withdraw after allocateBefore deadline"
          (now < allocation.settlement.allocateBefore)
        lockedHolding <- fetch lockedHoldingCid
        archive lockedHoldingCid
        returnCid <- create SimpleHolding with
          admin
          owner = allocation.transferLeg.sender
          instrumentId = allocation.transferLeg.instrumentId
          amount = lockedHolding.amount
          meta = emptyMetadata
        pure Allocation_WithdrawResult with
          senderHoldingCids = [toInterfaceContractId @Holding returnCid]
          meta = txKindMeta "transfer"


-- | Helper: archive locked holding and return unlocked holding to sender (for cancel).
-- Supports expire-lock pattern: if locked holding was already archived by owner,
-- "expire-lock" = False in context signals this.
releaseAllocatedFunds : Party -> AllocationSpecification -> ContractId LockedSimpleHolding -> ExtraArgs -> Update Allocation_CancelResult
releaseAllocatedFunds admin allocation lockedHoldingCid extraArgs = do
  let lockedHoldingActive = case lookupFromContext @Bool extraArgs.context expireLockContextKey of
        Right (Some False) -> False
        _ -> True
  if lockedHoldingActive
    then do
      lockedHolding <- fetch lockedHoldingCid
      archive lockedHoldingCid
      returnCid <- create SimpleHolding with
        admin
        owner = allocation.transferLeg.sender
        instrumentId = allocation.transferLeg.instrumentId
        amount = lockedHolding.amount
        meta = emptyMetadata
      pure Allocation_CancelResult with
        senderHoldingCids = [toInterfaceContractId @Holding returnCid]
        meta = txKindMeta "transfer"
    else do
      now <- getTime
      assertMsg "Locked holding not active but settlement has not expired"
        (now >= allocation.settlement.settleBefore)
      pure Allocation_CancelResult with
        senderHoldingCids = []
        meta = txKindMeta "transfer"
