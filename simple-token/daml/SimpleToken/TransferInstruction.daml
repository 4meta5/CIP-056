-- | Transfer instruction for two-step transfers.
-- Created when receiver has no preapproval; requires explicit accept/reject/withdraw.
module SimpleToken.TransferInstruction where

import Splice.Api.Token.MetadataV1
import Splice.Api.Token.HoldingV1
import Splice.Api.Token.TransferInstructionV1

import SimpleToken.Holding
import SimpleToken.ContextUtils

-- | A pending transfer instruction backed by a locked holding.
template SimpleTransferInstruction
  with
    admin : Party
    transfer : Transfer
    lockedHoldingCid : ContractId LockedSimpleHolding
    originalInstructionCid : Optional (ContractId TransferInstruction)
  where
    signatory admin, transfer.sender
    observer transfer.receiver

    interface instance TransferInstruction for SimpleTransferInstruction where
      view = TransferInstructionView with
        originalInstructionCid
        transfer
        status = TransferPendingReceiverAcceptance
        meta = emptyMetadata

      transferInstruction_acceptImpl selfCid arg = do
        -- Validate deadline before any archival (Gap 8)
        now <- getTime
        assertMsg "Transfer has expired (executeBefore passed)"
          (now < transfer.executeBefore)
        lockedHolding <- fetch lockedHoldingCid
        archive lockedHoldingCid
        let totalInput = lockedHolding.amount
        -- Create receiver holding
        receiverCid <- create SimpleHolding with
          admin
          owner = transfer.receiver
          instrumentId = transfer.instrumentId
          amount = transfer.amount
          meta = arg.extraArgs.meta
        -- Create sender change if needed
        senderChangeCids <- if totalInput > transfer.amount
          then do
            changeCid <- create SimpleHolding with
              admin
              owner = transfer.sender
              instrumentId = transfer.instrumentId
              amount = totalInput - transfer.amount
              meta = emptyMetadata
            pure [toInterfaceContractId @Holding changeCid]
          else pure []
        pure TransferInstructionResult with
          output = TransferInstructionResult_Completed with
            receiverHoldingCids = [toInterfaceContractId @Holding receiverCid]
          senderChangeCids
          meta = txKindMeta "transfer"

      transferInstruction_rejectImpl _selfCid arg = do
        returnLockedFundsToSender admin transfer lockedHoldingCid arg.extraArgs

      transferInstruction_withdrawImpl _selfCid arg = do
        returnLockedFundsToSender admin transfer lockedHoldingCid arg.extraArgs

      transferInstruction_updateImpl _selfCid _arg = do
        fail "TransferInstruction_Update is not supported"


-- | Helper: archive locked holding and return unlocked holding to sender.
-- Supports the expire-lock pattern: if the locked holding was already archived
-- (owner exercised LockedSimpleHolding_Unlock after lock expiry), the context
-- key "expire-lock" = False signals this, and we return Failed with empty
-- senderChangeCids (funds already returned via Unlock).
returnLockedFundsToSender : Party -> Transfer -> ContractId LockedSimpleHolding -> ExtraArgs -> Update TransferInstructionResult
returnLockedFundsToSender admin transfer lockedHoldingCid extraArgs = do
  let lockedHoldingActive = case lookupFromContext @Bool extraArgs.context expireLockContextKey of
        Right (Some False) -> False
        _ -> True  -- default: assume active (backward compatible)
  if lockedHoldingActive
    then do
      lockedHolding <- fetch lockedHoldingCid
      archive lockedHoldingCid
      returnCid <- create SimpleHolding with
        admin
        owner = transfer.sender
        instrumentId = transfer.instrumentId
        amount = lockedHolding.amount
        meta = emptyMetadata
      pure TransferInstructionResult with
        output = TransferInstructionResult_Failed
        senderChangeCids = [toInterfaceContractId @Holding returnCid]
        meta = txKindMeta "transfer"
    else do
      -- Locked holding already archived by owner. Verify deadline has passed.
      now <- getTime
      assertMsg "Locked holding not active but transfer has not expired"
        (now >= transfer.executeBefore)
      pure TransferInstructionResult with
        output = TransferInstructionResult_Failed
        senderChangeCids = []
        meta = txKindMeta "transfer"
